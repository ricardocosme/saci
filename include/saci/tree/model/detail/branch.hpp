#pragma once

#include "saci/tree/model/detail/node_impl_fwd.hpp"
#include "saci/tree/model/detail/T_is_function_obj.hpp"

namespace saci { namespace tree {

namespace detail {

//This is a hack to support serialization of a previous version that
//uses a class collection_branch_node to handle a branch_node when T
//was a FunctionObject. 
namespace legacy {

//This simulates the case where collectioon_branch_node was
//specialized with an implementation using a base class which was
//serializable. We need here to skip the metadata generated by
//Boost.Serialization that is associated to this base.
template<typename T,
         typename CheckPolicy,
         typename Children,
         typename Parent>
struct branch_node_base : branch_node<T, CheckPolicy, Children, Parent> {
    using base = branch_node<T, CheckPolicy, Children, Parent>;
    using base::base;
};

template<typename Parent, typename Tag, typename Enable = void>
struct get_branch_node;

template<typename Parent, typename Tag>
struct get_branch_node<
    Parent,
    Tag,
    enable_if_T_is_function_obj<typename Tag::type, Parent>>
{
    using type = branch_node_base<
        typename Tag::type,
        typename Tag::check_t,
        typename Tag::children,
        Parent>;
};

template<typename Parent, typename Tag>
struct get_branch_node<
    Parent,
    Tag,
    enable_if_T_is_not_function_obj<typename Tag::type, Parent>>
{
    using type = branch_node<
        typename Tag::type,
        typename Tag::check_t,
        typename Tag::children,
        Parent>;
};

} //namespace legacy

template<typename Parent, typename Tag>
struct node_impl<Parent, Tag, typename std::enable_if<
                      std::is_base_of<tag_branch, Tag>::value>::type> {
    using type = typename legacy::get_branch_node<Parent, Tag>::type;
};

template<typename Parent, typename Tag>
struct node_impl<Parent, Tag, typename std::enable_if<
                      std::is_base_of<tag_branches, Tag>::value>::type> {
    using type = coruja::list<
        typename legacy::get_branch_node<Parent, Tag>::type>;
};

}

}}
